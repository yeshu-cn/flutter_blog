{"title":"模块化分享记录","createTime":1589782578000,"updateTime":-1,"category":"架构设计","content":" \n  \n ## 当前的问题 \n * 不能单独复用业务层 \n * 业务Model定义不清晰，或者很难找到 \n * Repository定义为ViewModel的数据提供者，其中包含持久层+业务层，功能庞大，职责不明确 \n * UI层直接调用Repository，功能需求改变时会违反开闭原则 \n * UI层的Utils和Service层的Utils没有区分开 \n * Manager,Helper,Utils命名不统一 \n * 数据驱动界面更新编程方式不是银弹 \n  \n ## 组件化和模块化理解 \n  \n ### 组件化 \n 从使用方式来说，就是直接复用成品的Activity交互页面。在集成了组件化产品的不同app中，组件模块的交互页面是完全相同的。（类似于webView加载网页，不管哪个webView加载相同url看到的结果都是一样的） \n  \n **组件化是由产品决定要不要做的，是从产品层面设计的一个产品需求。** \n ### 模块化 \n 模块化就是写好代码，遵循面对对象编码的六大原则。 \n **模块化是开发内部决定的技术手段。** \n  \n 所以如果产品没有组件化需求，就不要做组件化。源头不对，再怎么尝试做组件化，都不可能做的好。都只是在过度设计。 \n  \n ## 不忘初衷：做好代码复用 \n 哪些代码可以复用？ \n 1. UI层 \n 产品没有做组件化的需求，所以UI层只复用自定义View，以UIComponent的方式提供复用 \n  \n 1. 业务层全部复用，创建Domain代表业务层，Domain内部角色: \n     * Model: 业务模型 \n     * Repository: 针对数据模型的增删改查 \n     * Service: 针对业务数据的整理等操作 \n     * UseCase: 通过repository和service实现针对应用页面的数据接口,也是domain层对外的统一接口 \n  \n ## 业务模块架构 \n ![4](1.jpg) \n  \n UseCase: \n UseCase中通过Repository获取业务Model,再通过Service将业务Model整理为页面需要的DTO \n  \n ViewModel: \n 通过一个对象完整的了解整个业务具有哪些数据 \n daoBean, apiBean需要考虑序列化存储，数据会不全，也不易理解 \n Model由具有唯一标示的实体（Entity）和值对象(Value Object)构成 \n  \n Repository: \n 提供针对业务Model的增删改查接口 \n  \n 优点： \n * UI只复用UIComponent \n * 定义业务Model,通过Model，Repository，Service就能大概了业务功能 \n * 代码层次结构，职责更加清晰，易维护 \n * 业务层和UI层的分离，抽离了与界面无关的抽象业务层，可单独复用 \n * 添加了业务层的访问接口UseCase,解决了需求变更时遵循开闭原则 \n  \n ## 单元测试实践 \n * webApi, deviceApi,Dao,Service,Utils 一般没有其他依赖，可以单元测试(unit test) \n * Repository会依赖webApi,deviceApi,Dao等，需要mock它们的实现进行测试(double test) \n * 使用robolectric让java test里面也可以依赖Android sdk 的api \n  \n ## Coroutines实践 \n * webApi, deviceApi, Dao, Service, repository, UseCase这些都只提供的main-safe的suspend方法"}