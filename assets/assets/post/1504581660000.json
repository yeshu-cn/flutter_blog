{"title":"Fragment使用中的常见异常","createTime":1504581660000,"updateTime":-1,"category":"default","content":" \n  \n ## 正确使用Fragment \n 如果系统重建Fragment会调用不带参数都构造函数，所以想要恢复保存参数需要使用`setArguments`方法设置参数`Bundle`。在Fragment重建时`Bundle`会自动保存下来。 \n  \n ``` \n public static MyFragment newInstance() { \n     Bundle args = new Bundle(); \n      \n     MyFragment fragment = new MyFragment(); \n     fragment.setArguments(args); \n     return fragment; \n } \n  \n public void onCreate() { \n \tBundle args = getArguments(); \n \t//... \n } \n ``` \n  \n ```java \n     @Override \n     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { \n         return inflater.inflate(R.layout.fragement, container, false);  \n     } \n ``` \n  \n  \n `inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)`参数说明： \n  \n 1. root不为null, attachToRoot为true时，将生成的View添加到root中 \n 2. root不为null, attachToRoot为false时，生成一个带params的View \n 3. root为null, attachToroot为false时, 生成一个不带params的View \n  \n  \n **Fragment和Activity的数据交互** \n  \n 为了解耦合,保持Fragment的独立性 \n  \n 1. Activity可以直接调用Fragment的public方法 \n 2. Fragment通过callback通知Activity \n  \n  \n ## 使用getChildFragmentManager时的\"no activity\"异常 \n  \n 触发流程 \n  \n 1. 使用Fragment.getChildFragmentManager \n 2. Fragment重复使用，再次attatch \n  \n ``` \n java.lang.IllegalStateException: No activity \n \tat android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1060) \n \tat android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1055) \n \tat android.app.FragmentManagerImpl.dispatchActivityCreated(FragmentManager.java:1864) \n \tat android.app.Fragment.performActivityCreated(Fragment.java:1714) \n \tat android.app.FragmentManagerImpl.moveToState(FragmentManager.java:919) \n \tat android.app.FragmentManagerImpl.moveToState(FragmentManager.java:1073) \n \tat android.app.BackStackRecord.run(BackStackRecord.java:698) \n \tat android.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:1458) \n \tat android.app.FragmentManagerImpl$1.run(FragmentManager.java:443) \n \tat android.os.Handler.handleCallback(Handler.java:808) \n \tat android.os.Handler.dispatchMessage(Handler.java:103) \n \tat android.os.Looper.loop(Looper.java:193) \n \tat android.app.ActivityThread.main(ActivityThread.java:5332) \n \tat java.lang.reflect.Method.invokeNative(Native Method) \n \tat java.lang.reflect.Method.invoke(Method.java:515) \n \tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:829) \n \tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:645) \n \tat dalvik.system.NativeStart.main(Native Method) \n  \n ``` \n  \n Fragment destory时会将mChildFragmentManager.mHost重置为null \n  \n ```java \n void performDestroy() { \n     if (mChildFragmentManager != null) { \n         mChildFragmentManager.dispatchDestroy(); \n     } \n \t//... \n } \n  \n public void dispatchDestroy() { \n     moveToState(Fragment.INITIALIZING, false); \n     mHost = null; \n } \n ``` \n  \n 导致Fragment再次attach时 mChildFragmentManager.mHost = null \n  \n ```java \n public void dispatchActivityCreated() { \n     mStateSaved = false; \n     moveToState(Fragment.ACTIVITY_CREATED, false); \n } \n  \n  void moveToState(int newState, int transit, int transitStyle, boolean always) { \n     if (mHost == null && newState != Fragment.INITIALIZING) { \n         throw new IllegalStateException(\"No activity\"); \n     } \n  \n    \t//... \n } \n ``` \n  \n Fragment attach时mChildFragmentManager != null \n  \n ```java \n final public FragmentManager getChildFragmentManager() { \n     if (mChildFragmentManager == null) { \n         instantiateChildFragmentManager(); \n \t\t\t//... \n     } \n     return mChildFragmentManager; \n } \n      \n void instantiateChildFragmentManager() { \n     mChildFragmentManager = new FragmentManagerImpl(); \n     mChildFragmentManager.attachController(mHost, new FragmentContainer() { \n         //... \n     }, this); \n } \n      \n ``` \n  \n 解决方法就是在Fragment desotry时，将其FragmentManager也设置为null \n  \n 参考资料： \n  \n * https://issuetracker.google.com/issues/36963722 \n * https://stackoverflow.com/questions/27980543/viewpager-on-dialogfragment-java-lang-illegalstateexception-no-activity \n  \n  \n ## Fragment detach后使用mHost报错 \n  \n 只能在attached Activity之前调用，所以，在实例化对象后立刻调用 \n  \n ```java \n public void setArguments(Bundle args) { \n \tif (mIndex > 0) { \n \t\tthrow new IllegalStateException(\"Fragment already active\"); \n \t} \n \t \n \tmArguments = args; \n } \n ``` \n  \n Fragment detache了后调用getResources()会报错 \n  \n ```java \n final public Resources getResources() { \n     if (mHost == null) { \n         throw new IllegalStateException(\"Fragment \" + this + \" not attached to Activity\"); \n     } \n     return mHost.getContext().getResources(); \n } \n ``` \n  \n ## Fragment 重影问题 \n  \n **问题原因** \n  \n Activity因为内存不足悲销毁重建时，其中Fragment也会被销毁重建。如果此时Activity onCreate中addFragment多次，就会造成重影问题 \n  \n **模拟系统销毁Activity的方法** \n  \n 手机的 \"设置\" - \"开发者选项\" - 打开\"不保留活动\" \n  \n ## BackStackRecored 不能commit多次 \n  \n ```java \n     int commitInternal(boolean allowStateLoss) { \n         if (mCommitted) { \n             throw new IllegalStateException(\"commit already called\"); \n         } \n         if (FragmentManagerImpl.DEBUG) { \n             Log.v(TAG, \"Commit: \" + this); \n             LogWriter logw = new LogWriter(Log.VERBOSE, TAG); \n             PrintWriter pw = new FastPrintWriter(logw, false, 1024); \n             dump(\"  \", null, pw, null); \n             pw.flush(); \n         } \n         mCommitted = true; \n         if (mAddToBackStack) { \n             mIndex = mManager.allocBackStackIndex(this); \n         } else { \n             mIndex = -1; \n         } \n         mManager.enqueueAction(this, allowStateLoss); \n         return mIndex; \n     } \n ``` \n  \n ## Fragment重复使用错误 \n  \n 1. Fragment不能同时加到两个不同的containerView中 \n 2. Fragment不能同时add两个不同的tag \n  \n ```java \n private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) { \n     fragment.mFragmentManager = mManager; \n  \n     if (tag != null) { \n         if (fragment.mTag != null && !tag.equals(fragment.mTag)) { \n             throw new IllegalStateException(\"Can't change tag of fragment \" \n                     + fragment + \": was \" + fragment.mTag \n                     + \" now \" + tag); \n         } \n         fragment.mTag = tag; \n     } \n  \n     if (containerViewId != 0) { \n         if (fragment.mFragmentId != 0 && fragment.mFragmentId != containerViewId) { \n             throw new IllegalStateException(\"Can't change container ID of fragment \" \n                     + fragment + \": was \" + fragment.mFragmentId \n                     + \" now \" + containerViewId); \n         } \n         fragment.mContainerId = fragment.mFragmentId = containerViewId; \n     } \n  \n     Op op = new Op(); \n     op.cmd = opcmd; \n     op.fragment = fragment; \n     addOp(op); \n } \n ``` \n  \n ## 源码阅读 \n  \n **主要成员** \n  \n * Activity \n  \n \t\tfinal Handler mHandler = new Handler(); \n \t\t//即FragmentManager \n    \t\tfinal FragmentController mFragments = FragmentController.createController(new HostCallbacks()); \n \t\t \n * Fragment \n  \t\t \n  \t\t里面有个ChildFragmentManager \n \t \n * FragmentManager \n \t\t \n \t\t具体实现类是FragmentManagerImpl，有个moveToState()方法，用于切换状态，回调Fragment中的相关声明周期 \n  \n \t \n * BackStackRecord \n  \n \t\t就是FragmentTransaction，里面包含一个用于保存add,replace,commit等操作的双向链表，是一个runable。 \n \t\tcommit是通过mFragmentManager中的mHandler来执行这个BackStackRecord runnable. \n \t\t \n \t \n **参考资料**   \n  \n * moveToState函数，Fragment生命周期函数调用解释（http://www.jianshu.com/p/c8391673babe） \n * 比较全面的源码解析（http://www.jianshu.com/p/bd4a8be309c8）"}