{"title":"Android MVP架构笔记","createTime":1460939305000,"updateTime":1460908949000,"category":"default","content":" \n  \n Basic Model-View-Presenter architecture. [Android 官方架构Demo](ttps://github.com/googlesamples/android-architecture/tree/todo-mvp) \n  \n  \n #### TO-DO-MVP项目按页面模块划分 \n 页面模块 \n  \n * addedittask \n * tasks \n * statistics \n * taskdetai \n  \n data 和 utils \n  \n * data \n * utils \n  \n  \n 两个基类：BaseView，BasePresenter \n  \n 命名方式： \n  \n ``` \n //布局文件命名 \n addtask_act.xml \n addtask_frag.xml \n task_item.xml \n  \n //资源文件命名 \n ic_xxx.png \n  \n <color name=\"colorPrimary\">#455A64</color> \n <color name=\"colorPrimaryDark\">#263238</color> \n <color name=\"colorAccent\">#D50000</color>   \n  \n //xml中id命名 \n android:id=\"@+id/noTasksIcon\" \n ``` \n  \n #### Model and Repository \n  \n * Task \n * TasksRepository:by using the remote data source only if the local database doesn't exist or is empty. \n  \n TasksDataSource(interface)定义task的增删改查操作：获取，保存、更新、删除。 \n  \n 1. 函数名为业务方式, \n 2. 函数的操作对象必须是Task,参数为Task或者Task相关属性 \n  \n DataSource分为TasksRemoteDataSource和TasksLocalDataSource,分别都实现TasksDataSource接口 \n  \n TasksRepository则是用户维护管理两个DataSource的。 \n  \n Repostory中包含数据模型的操作 \n  \n  \n #### Activity \n `TasksActivity`包含`TasksPresenter` \n  \n * 初始化必要的界面代码，如`toolbar`, `drawerLayout`，加载`fragment` \n * 实例化`Presenter` \n  \n  \n #### Presneter and View \n `TasksPresenter`作用:监听UI事件，执行业务逻辑，获取数据并更新UI显示 \n  \n `TasksContract`：包含`View`和`Presenter`两个接口,用于定义`View`和`Presenter`的行为， \n  \n  \n `Presenter`包含`Repository`和`view` \n `TasksFragment`作为`View`包含`Presenter` \n  \n `Presenter`负责处理业务相关函数 \n `View`负责处理UI显示的函数 \n  \n `View`中单纯的全部是`View`的展示方法,但是`View`中包含`Presenter`，因为一些UI的交互必须从其中`View`中传递告诉`Presenter` \n  \n `Presenter`中包含业务方法、`Repository`和成员`View`，因为业务需要数据和控制UI的展示 \n  \n ## 总结 \n  \n `MVP`构成其实包含：（`Model`,`Repository`）, `Presenter`, `View` \n 其中核心代码： \n  \n * `Model`：业务模型的定义 \n * `Presenter`和`View`的`Interface`的定义。这两个定义清楚了，整个项目的层次就会很清楚 \n  \n #### 实践 \n  \n 在工作中，虽然没有单独的实现`Presenter`和`View`文件。但已经尝试将代码按照`View`的UI展示方法方法和`Presneter`的业务方法进行区分，如果需要重构为`MVP`的话只需要将其中方法提取至单独的`Presenter`和`View`中即可。 \n  \n 因为感觉不是很大的项目，不想建立太多的`Presenter`和`View`文件，所以代码还是全部写在Activity中，如果项目足够大的话，会考虑用标准的mvp项目文件架构形式 \n  \n 这样做的成果就是需求变动的时候往往只需要注释掉莫行代码即可，快速无误，不用担心对其他业务逻辑或UI显示造成影响。 \n  \n  \n  \n #### MVP思想写代码 \n  \n * `View`层负责UI展示，`Presenter`层负责业务逻辑。两部分代码需要隔离分清楚，函数级别的松耦合，易维护，复用性高（对应抽象成单独的`Presenter`,`View`类文件，是文件类级别的）。 \n * 有一个`Model`业务模型大家都知道，但是`Repository`层总是没能理清楚。（参考DDD中的Repository） \n  \n  \n #### `MVC`的问题 \n `MVC`中的`Activity`即充当`View`又充当`Controller`。其中的逻辑代码紧紧的关联着UI，不能复用，混乱。 \n  \n ## 别人的说法 \n <http://blog.csdn.net/vector_yi/article/details/24719873> \n  \n 缺点：额外的代码复杂度及学习成本。多了Presenter和View类 \n  \n 优点： \n  \n 1. 降低耦合度 \n 2. 模块职责划分明显 \n 3. 利于测试驱动开发 \n 4. 代码复用 \n 5. 隐藏数据 \n 6. 代码灵活性 \n  \n **因：** \n Activity并不是一个标准的MVC模式中的Controller， 它的首要职责是加载应用的布局和初始化用户界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。 \n  \n **果：** \n 我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由Presenter处理）. \n "}