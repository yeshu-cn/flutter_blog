{"title":"android-advancedrecyclerview 滑动功能源码分析","createTime":1476327463000,"updateTime":-1,"category":"default","content":" \n  \n 带着问题去阅读源码 \n  \n  \n  \n ### 问题 \n  \n #### 如何实现滑动显示菜单的界面 \n  \n itemView的布局 \n  \n ```xml \n <?xml version=\"1.0\" encoding=\"utf-8\"?> \n <!-- NOTE: should use FrameLayout or RelativeLayout for parent of the \"@id/container\" view (for Android 2.3 compatibility) --> \n <FrameLayout \n     style=\"@style/commonListItemStyle\" \n     xmlns:android=\"http://schemas.android.com/apk/res/android\" \n     xmlns:tools=\"http://schemas.android.com/tools\" \n     android:layout_width=\"match_parent\" \n     android:layout_height=\"@dimen/list_item_height\" \n     android:background=\"@drawable/bg_swipe_item_neutral\"> \n  \n     <FrameLayout \n         android:id=\"@+id/container\" \n         android:layout_width=\"match_parent\" \n         android:layout_height=\"match_parent\" \n         android:clickable=\"true\" \n         android:foreground=\"?attr/selectableItemBackground\" \n         tools:ignore=\"UselessParent\"> \n  \n         <TextView \n             android:id=\"@android:id/text1\" \n             android:layout_width=\"match_parent\" \n             android:layout_height=\"match_parent\" \n             android:layout_gravity=\"top|left\" \n             android:gravity=\"center\" \n             tools:ignore=\"RtlHardcoded\"/> \n  \n     </FrameLayout> \n </FrameLayout> \n  \n  \n ``` \n  \n 其中`container`就是正常情况下显示的item界面，菜单的界面是通过设置根容器`FrameLayout`的background实现，如下就是菜单的布局 \n  \n ```xml \n <layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"> \n     <item> \n         <color android:color=\"@color/bg_swipe_group_item_pinned\"/> \n     </item> \n     <item android:right=\"16dp\"> \n         <bitmap \n             android:src=\"@drawable/ic_item_swipe_pinned\" \n             android:gravity=\"right|center_vertical\"/> \n     </item> \n </layer-list> \n ``` \n  \n 滑动时动态设置background以实现菜单的显示 \n  \n ```java \n //设置菜单的显示 \n @Override \n public void onSetSwipeBackground(MyViewHolder holder, int position, int type) { \n     int bgRes = 0; \n     switch (type) { \n         case Swipeable.DRAWABLE_SWIPE_NEUTRAL_BACKGROUND: \n                 //没有滑动时显示默认背景 \n             bgRes = R.drawable.bg_swipe_item_neutral; \n             break; \n         case Swipeable.DRAWABLE_SWIPE_LEFT_BACKGROUND: \n                 //向左滑动时设置左菜单 \n             bgRes = R.drawable.bg_swipe_item_left; \n             break; \n         case Swipeable.DRAWABLE_SWIPE_RIGHT_BACKGROUND: \n                 //向右滑动时设置右菜单 \n             bgRes = R.drawable.bg_swipe_item_right; \n             break; \n     } \n  \n     //菜单界面，其实就是itemView的background \n     holder.itemView.setBackgroundResource(bgRes); \n } \n ``` \n  \n 监听holder.itemView的点击事件即为菜单的点击事件   \n 监听holder.itemView.container的点击事件即为item的点击事件 \n  \n ```java \n public SwipeableExampleAdapter(AbstractDataProvider dataProvider) { \n     //... \n     mItemViewOnClickListener = new View.OnClickListener() { \n         @Override \n         public void onClick(View v) { \n                 //点击了holder.itemView \n             onItemViewClick(v); \n         } \n     }; \n     mSwipeableViewContainerOnClickListener = new View.OnClickListener() { \n         @Override \n         public void onClick(View v) { \n                 //点击了item.itemView.container \n             onSwipeableViewContainerClick(v); \n         } \n     }; \n     //... \n  \n } \n  \n  \n private void onItemViewClick(View v) { \n     if (mEventListener != null) { \n         //pinned为true表示显示了菜单界面，这里即意味着菜单被点击了 \n         mEventListener.onItemViewClicked(v, true); // true --- pinned \n     } \n } \n  \n private void onSwipeableViewContainerClick(View v) { \n     if (mEventListener != null) { \n         //意味着item被点击了 \n         mEventListener.onItemViewClicked(RecyclerViewAdapterUtils.getParentViewHolderItemView(v), false);  // false --- not pinned \n     } \n } \n ``` \n  \n #### 触摸事件判断是在哪里处理的 \n  \n RecyclerViewSwipeManager中注册了RecyclerView.OnItemTouchListener,以实现将RecyclerView中的触摸事件转移到RecyclerViewSwipeManager中的`onInterceptTouchEvent`,`onTouchEvent`判断 \n  \n ```java \n //new RecyclerViewSwipeManager时实例化Listener \n public RecyclerViewSwipeManager() { \n     mInternalUseOnItemTouchListener = new RecyclerView.OnItemTouchListener() { \n         @Override \n         public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { \n                 //将RecyclerView的touch事件转移给自己处理 \n             return RecyclerViewSwipeManager.this.onInterceptTouchEvent(rv, e); \n         } \n  \n         @Override \n         public void onTouchEvent(RecyclerView rv, MotionEvent e) { \n             RecyclerViewSwipeManager.this.onTouchEvent(rv, e); \n         } \n  \n         @Override \n         public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) { \n             RecyclerViewSwipeManager.this.onRequestDisallowInterceptTouchEvent(disallowIntercept); \n         } \n     }; \n     //... \n } \n ``` \n  \n ```java \n //attach recyclerView的时候注册Listener \n public void attachRecyclerView(@NonNull RecyclerView rv) { \n     //... \n     mRecyclerView.addOnItemTouchListener(mInternalUseOnItemTouchListener); \n     //.. \n } \n ``` \n RecyclerView中如果有touchListener消费了事件，则事件将不会继续传递给后续的函数,如下代码： \n  \n ```java \n //RecyclerView.java \n public boolean onInterceptTouchEvent(MotionEvent e) { \n     if (mLayoutFrozen) { \n         // When layout is frozen,  RV does not intercept the motion event. \n         // A child view e.g. a button may still get the click. \n         return false; \n     } \n     if (dispatchOnItemTouchIntercept(e)) { \n         cancelTouch(); \n         //如果事件被listener处理了，则到此结束了 \n         return true; \n     } \n  \n     //... \n ｝ \n  \n private boolean dispatchOnItemTouchIntercept(MotionEvent e) { \n     final int action = e.getAction(); \n     if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_DOWN) { \n         mActiveOnItemTouchListener = null; \n     } \n  \n     final int listenerCount = mOnItemTouchListeners.size(); \n     for (int i = 0; i < listenerCount; i++) { \n         final OnItemTouchListener listener = mOnItemTouchListeners.get(i); \n         if (listener.onInterceptTouchEvent(this, e) && action != MotionEvent.ACTION_CANCEL) { \n             mActiveOnItemTouchListener = listener; \n             //注意此处listener注册是有优先级的，只要有一个消费了就直接返回，剩余的listener不会再被调用了 \n             return true; \n         } \n     } \n     return false; \n } \n      \n ``` \n  \n #### 如何判断滑动还是滚动 \n  \n RecyclerViewSwipeManager中`onInterceptTouchEvent`,`onTouchEvent`判断 \n  \n ```java \n boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { \n     final int action = MotionEventCompat.getActionMasked(e); \n  \n     switch (action) { \n         case MotionEvent.ACTION_UP: \n         case MotionEvent.ACTION_CANCEL: \n             if (handleActionUpOrCancel(e, true)) { \n                 return true; \n             } \n             break; \n  \n         case MotionEvent.ACTION_DOWN: \n             if (!isSwiping()) { \n                 handleActionDown(rv, e); \n             } \n             break; \n  \n         case MotionEvent.ACTION_MOVE: \n             if (isSwiping()) { \n                     //这个isSwiping()判断其实是不需要的，作者说有bug才加上这个。我没遇到这个bug \n                 // NOTE: The first ACTION_MOVE event will come here. (maybe a bug of RecyclerView?) \n                 handleActionMoveWhileSwiping(e); \n                 return true; \n             } else { \n                 if (handleActionMoveWhileNotSwiping(rv, e)) { \n                     //如果是滑动事件，则拦截 \n                     return true; \n                 } \n             } \n             break; \n     } \n  \n     return false; \n } \n  \n void onTouchEvent(RecyclerView rv, MotionEvent e) { \n     final int action = MotionEventCompat.getActionMasked(e); \n  \n     switch (action) { \n         case MotionEvent.ACTION_UP: \n         case MotionEvent.ACTION_CANCEL: \n             handleActionUpOrCancel(e, true); \n             break; \n  \n         case MotionEvent.ACTION_MOVE: \n             //滑动View \n             handleActionMoveWhileSwiping(e); \n             break; \n     } \n } \n ``` \n  \n onInterceptTouchEvent中的ACTION_DOWN纪录按下时的状态，ACTION_MOVE中判断是滚动还是滑动， \n  \n 如果是滑动则拦截事件,将以后ACTION_MOVE事件交由`onTouchEvent`中的`handleActionMoveWhileSwiping()`进行View的滑动。 \n  \n 如果是滚动事件，则不拦截，默认是RecyclerView的滚动 \n  \n #### 详细看看是如何判断是滑动事件的 \n  \n ```java \n //精简了下代码 \n private boolean handleActionMoveWhileNotSwiping(RecyclerView rv, MotionEvent e) { \n         //... \n         final int dx = (int) (e.getX() + 0.5f) - mInitialTouchX; \n         final int dy = (int) (e.getY() + 0.5f) - mInitialTouchY; \n  \n         final int scrollAxisDelta; //滚动的距离 \n         final int swipeAxisDelta;        //滑动的距离 \n  \n         scrollAxisDelta = dy; \n         swipeAxisDelta = dx; \n  \n         //如果滚动的距离大于mTouchSlop，那么表示发生了滚动，直接返回false,让默认代码处理RecyclerView的滚动 \n         if (Math.abs(scrollAxisDelta) > mTouchSlop) { \n             // scrolling occurred \n             return false; \n         } \n          \n         //如果滑动距离过小，那也不处理，返回false \n         if (Math.abs(swipeAxisDelta) <= mTouchSlop) { \n             return false; \n         } \n          \n          //... \n          return true; \n     } \n ``` \n  \n #### 判断滑动后如何滑动View \n  \n `RecyclerViewSwipeManager中`的`onTouchEvent`的`ACTION_MOVE`事件中会调用`handleActionMoveWhileSwiping()`方法滑动holder.itemView.container \n  \n ```java \n private void handleActionMoveWhileSwiping(MotionEvent e) { \n     mLastTouchX = (int) (e.getX() + 0.5f); \n     mLastTouchY = (int) (e.getY() + 0.5f); \n     mVelocityTracker.addMovement(e); \n  \n     final int swipeDistanceX = mLastTouchX - mTouchedItemOffsetX; \n     final int swipeDistanceY = mLastTouchY - mTouchedItemOffsetY; \n     final int swipingItemPosition = getSwipingItemPosition(); \n  \n     //SwipingItemOperator会去判断得出最终的滑动方式 \n     mSwipingItemOperator.update(swipingItemPosition, swipeDistanceX, swipeDistanceY); \n } \n  \n public void update(int itemPosition, int swipeDistanceX, int swipeDistanceY) { \n     //... \n  \n     //计算好各种滑动信息后，最终又回到了RecyclerViewSwipeManager.applySlideItem()中去了执行真正的滑动了 \n     mSwipeManager.applySlideItem( \n             mSwipingItem, itemPosition, \n             mPrevTranslateAmount, translateAmount, true, \n             mSwipeHorizontal, false, true); \n  \n     mPrevTranslateAmount = translateAmount; \n } \n  \n //applySlideItem又会调用slideItem \n private void slideItem(RecyclerView.ViewHolder holder, float amount, boolean proportionalAmount, boolean horizontal, boolean shouldAnimate) { \n     if (amount == OUTSIDE_OF_THE_WINDOW_LEFT) { \n             //最后使用属性动画，设置setTranslationX属性去实现移动 \n         mItemSlideAnimator.slideToOutsideOfWindow(holder, ItemSlidingAnimator.DIR_LEFT, shouldAnimate, mMoveToOutsideWindowAnimationDuration); \n     }  \n     //... \n } \n  \n ``` \n  \n ### 架构设计 \n  \n 看它代码觉得每个类的职责划分的很明确 \n  \n `SwipeableItemAdapter` ： \n  \n 1. 成员ViewHolder负责UI \n 2. 成员AbstractDataProvider负责数据的提供和数据的删除，恢复，移动逻辑。 \n 3. 成员EventListener负责交互事件的处理 \n 4. 它继承子BaseSwipeableItemAdapter,其中定义了`onGetSwipeReactionType()`,`onSetSwipeBackground()`两个函数用于实现滑动时item背景变化和菜单的显示 \n  \n `SwipeableItemWrapperAdapter` : 将RecyclerViewSwipeManager和Adapter关联起来 \n  \n `RecyclerViewSwipeManager`：负责监测是否时滑动事件，并处理滑动相关的逻辑 \n  \n 1. 成员`SwippingItemOperator` ：处理swipe result \n 2. 成员`ItemSlidingAnimator` ：负责View的滑动 \n  \n `RecyclerViewTouchActionGuardManager`：处理显示滑动动画时，屏蔽触摸事件 \n  \n  \n ### 名词解释 \n  \n * `ViewHolder.itemView` 为整个ItemView视图，包括隐藏的菜单 \n * `ViewHolder.mContainer` 为正常情况下显示的item（即holder.itemView.container） \n * `pinned` 为true表示当前滑动菜单处于显示状态 \n * swipteState 滑动状态 \n  \n         Switeable.STATE_FLAG_IS_ACTIVE //长按选中状态   \n         Switeable.STATE_FLAG_IS_SWIPING //正在滑动状态  \n * swipe result 滑动结果 \n      \n         RESULT_NONE \n         RESULT_CANCELED \n         RESULT_SWIPED_LEFT \n         RESULT_SWIPED_UP \n         RESULT_SWIPED_RIGHT \n         RESULT_SWIPED_DOWN \n  \n  \n  \n ### 看源码时查的资料 \n  \n  \n 1. 属性动画介绍（setTranslationX属性实现移动效果）：http://blog.csdn.net/yanzi1225627/article/details/47850471 \n 2. Android坐标系介绍（很详细）:http://blog.csdn.net/yanbober/article/details/50419117 \n 3. onInterceptTouchEvent中拦截判断一次成功后，就不需要再次判断了 \n  \n > RecyclerView.OnItemTouchListener中，onInterceptTouchEvent拦截了ACTION_MOVE过后，后续的ACTION_MOVE事件分发就不在走onInterceptTouchEvent了，直接分发到onTouchEvent \n >  \n > onInterceptTouchEvent只会执行一次（dispatchTouchEvent发现mFirstTouchTarget为null，即后面没有需要接收事件的view时，就不会进行拦截判断了）：http://www.jianshu.com/p/8c9d2bdbac57 \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n "}