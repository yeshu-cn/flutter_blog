{"title":"ExoPlayer2-使用","createTime":1511169905000,"updateTime":-1,"category":"default","content":" \n  \n # ExoPlayer2-使用 \n  \n https://google.github.io/ExoPlayer/guide.html \n  \n ## 缺点 \n  \n * 使用ExoPlayer时，Android版本必须在Android 4.1(API level 16)以后，因为ExoPlayer播放音频、视频是基于Android 4.1上增加的`MediaCodec`接口实现的 \n * Widevine这个数字版权管理功能只能在Android 4.4(API level 19)后才能使用 \n  \n  \n ## Library overView \n  \n ExoPlayer library 最核心的部分是`ExoPlayer`接口。它提供了视频播放中最常用的功能，如播放，暂停，拖动，缓冲视频。`ExoPlayer`将视频的加载和渲染抽象为如下三个组件： \n  \n * MediaSource \n \t\t \n \t\t负责媒体的下载，播放，决定已缓冲的媒体是否可读。`MediaSource`通过`ExoPlayer.prepare`函数注入使用 \n * TrackSelector  \n \t\t \n \t\t负责从`MediaSource`中获取媒体块数据，提供给`Renderer`渲染使用。在player创建的时候注入使用 \n * LoadControl \n  \n \t\t负责`MediaSource`中何时、如何缓冲数据的策略，在player创建时注入使用 \n  \n Library中针对常用情况对三个组件有默认的实现，为了方便自定义扩展功能，他们都是通过注入的方式传入ExoPlayer。 \n  \n ## Getting started \n  \n 使用ExoPlayer步骤 \n  \n 1. 项目中添加`Library`依赖 \n 2. 创建`SimpleExoPlayer`实例 \n 3. 关联Player到View(显示视频画面，接收用户输入) \n 4. 为Player准备好`MediaSource`,并播放 \n 5. 播放结束后，释放player资源 \n  \n  \n ### 添加`library`以来 \n 项目`build.gradle`文件中添加仓库地址 \n  \n ``` \n repositories { \n     jcenter() \n     google() \n } \n ``` \n  \n module `build.gradle`文件中添加以来 \n  \n ``` \n //添加库的全部特性 \n implementation 'com.google.android.exoplayer:exoplayer:r2.X.X' \n  \n ``` \n  \n 或者按需添加 \n  \n  \n ``` \n compile 'com.google.android.exoplayer:exoplayer-core:r2.X.X' \n compile 'com.google.android.exoplayer:exoplayer-dash:r2.X.X' \n compile 'com.google.android.exoplayer:exoplayer-ui:r2.X.X' \n  \n ``` \n  \n 完整的`ExoPlayer libray`包含如下独立的`library module` \n  \n  \n * exoplayer-core: Core functionality (required). \n * exoplayer-dash: Support for DASH content. \n * exoplayer-hls: Support for HLS content. \n * exoplayer-smoothstreaming: Support for SmoothStreaming content. \n * exoplayer-ui: UI components and resources for use with ExoPlayer. \n \t\t \n  \n ### 创建player \n  \n ```java \n // 1. Create a default TrackSelector \n Handler mainHandler = new Handler(); \n BandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(); \n TrackSelection.Factory videoTrackSelectionFactory = \n     new AdaptiveTrackSelection.Factory(bandwidthMeter); \n TrackSelector trackSelector = \n     new DefaultTrackSelector(videoTrackSelectionFactory); \n  \n // 2. Create the player \n SimpleExoPlayer player = \n     ExoPlayerFactory.newSimpleInstance(context, trackSelector); \n ``` \n  \n ### 关联Player到View \n  \n `ExoPlayer library`提供`SimpleExoPlayerView`,它包含`PlaybackControlView`和`Surface`。可以在layout.xml文件中直接使用它，关联代码如下： \n  \n ```java \n // Bind the player to the view. \n simpleExoPlayerView.setPlayer(player); \n  \n ``` \n  \n 如果需要自定义视频的控制和视频渲染，可以使用`SimpleExoPlayer`的如下方法 \n  \n * `setVideoSurfaceView` \n * `setVideoTExtureview` \n * `setVideoSurfaceHolder` \n * `setVideoSurface` \n  \n ### Player准备 \n  \n `MediaSource`代表着媒体资源，所以需要在`ExoPlayer.prepare`时就创建好,并传入一个`MediaSource`。ExoPlayer library中提供了默认如下默认的实现： \n  \n * DashMediaSource -> DASH \n * SsMediaSource -> SmoothStreaming \n * HlsMediaSource -> HLS \n * ExtractorMediaSource -> regular media files \n  \n 播放mp4文件代码示例： \n  \n ```java \n // Measures bandwidth during playback. Can be null if not required. \n DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(); \n // Produces DataSource instances through which media data is loaded. \n DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(context, \n     Util.getUserAgent(context, \"yourApplicationName\"), bandwidthMeter); \n // Produces Extractor instances for parsing the media data. \n ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory(); \n // This is the MediaSource representing the media to be played. \n MediaSource videoSource = new ExtractorMediaSource(mp4VideoUri, \n     dataSourceFactory, extractorsFactory, null, null); \n // Prepare the player with the source. \n player.prepare(videoSource); \n  \n ``` \n  \n ### 控制播放 \n  \n 当player准备好了以后，可以如下方法控制播放： \n  \n * setPlayWhenReady \n * seekTo \n * setRepeatMode \n * setPlaybackParameters \n  \n  \n ### 释放资源 \n  \n 播放结束后需要释放`video decoders`等有限的资源给其他应用使用，调用`ExoPlayer.release`释放资源。 \n  \n ## MediaSource \n  \n `MediaSource`实例不能重复使用，如果需要多次初始化player,每次都必须使用新的实例 \n  \n * DashMediaSource \n * SsMediaSource \n * HlsMediaSource \n * ExtractorMediaSource \n * MergingMediaSource \n * LoopingMediaSource \n * ContractenatingMediaSource \n * DynamicConcatenatingMediaSource \n  \n ### 加载字幕文件 \n  \n 提供一个视频文件和字幕文件，`mergingMediaSource`可以将他们合并为一个资源来播放 \n  \n ```java \n // Build the video MediaSource. \n MediaSource videoSource = new ExtractorMediaSource(videoUri, ...); \n // Build the subtitle MediaSource. \n Format subtitleFormat = Format.createTextSampleFormat( \n     id, // An identifier for the track. May be null. \n     MimeTypes.APPLICATION_SUBRIP, // The mime type. Must be set correctly. \n     selectionFlags, // Selection flags for the track. \n     language); // The subtitle language. May be null. \n MediaSource subtitleSource = new SingleSampleMediaSource( \n     subtitleUri, dataSourceFactory, subtitleFormat, C.TIME_UNSET); \n // Plays the video with the sideloaded subtitle. \n MergingMediaSource mergedSource = \n     new MergingMediaSource(videoSource, subtitleSource); \n ``` \n  \n  \n ### 循环播放视频 \n  \n 有两种方法 \n  \n * ExoPlayer.setRepeatMode (推荐) \n * 使用LoopingMediaSource \n  \n \t```java \n \tMediaSource source = new ExtractorMediaSource(videoUri, ...); \n \t// Plays the video twice. \n \tLoopingMediaSource loopingSource = new LoopingMediaSource(source, 2); \n \t \n \t``` \n  \n ### 播放视频列表 \n  \n `ConcatenatingMediaSource`可以实现无缝播放视频列表，视频列表的文件格式和视频清晰度都可以不同。 \n  \n ```java \n MediaSource firstSource = new ExtractorMediaSource(firstVideoUri, ...); \n MediaSource secondSource = new ExtractorMediaSource(secondVideoUri, ...); \n // Plays the first video, then the second video. \n ConcatenatingMediaSource concatenatedSource = \n     new ConcatenatingMediaSource(firstSource, secondSource); \n ``` \n  \n `DynamicConcatenatingMediaSource`和`ConcatenatingMediaSource`类似，只是可以播放过程中添加，删除播放列表内容。 \n  \n **注意`MediaSource`不能重复添加，或者添加之前删除过的`MediaSource`。需要使用新的实例** \n  \n ### 播放视频A两次，后播放视频B(A,A,B) \n  \n ```java \n MediaSource firstSource = new ExtractorMediaSource(firstVideoUri, ...); \n MediaSource secondSource = new ExtractorMediaSource(secondVideoUri, ...); \n // Plays the first video twice. \n LoopingMediaSource firstSourceTwice = new LoopingMediaSource(firstSource, 2); \n // Plays the first video twice, then the second video. \n ConcatenatingMediaSource concatenatedSource = \n     new ConcatenatingMediaSource(firstSourceTwice, secondSource); \n ``` \n  \n or \n  \n ```java \n MediaSource firstSource = new ExtractorMediaSource(firstVideoUri, ...); \n MediaSource secondSource = new ExtractorMediaSource(secondVideoUri, ...); \n // Plays the first video twice, then the second video. \n ConcatenatingMediaSource concatenatedSource = \n     new ConcatenatingMediaSource(firstSource, firstSource, secondSource); \n  \n ``` \n  \n **注意此处firstSource这个`MediaSource`实例使用了两次，仅限特殊函数才能使用同一实例** \n  \n ## Player Events \n  \n 常用的方法有 \n  \n * addListener \n * removeListener \n * addVideoListener \n * setVideoDebugListener \n * setAudioDebugListener \n  \n  \n ## Sending messages to components \n  \n * sendMessages \n * blockingSendMessages \n  \n ## 自定义 \n  \n 可以自定义实现如下组件 \n  \n * Renderer -> 自定义Renderer支持新类型的媒体 \n * TrackSelector -> 自定义如何提供数据给Renderer \n * LoadControl -> 自定义缓存策略 \n * Extractor -> 自定义实现支持新的格式 \n * MediaSource -> 自定义如何提供数据给Renderer \n * DataSource -> 自定义如何下载数据，例如通过自定义协议下载数据或者通过本地缓存加载数据 \n  \n  \n ## 数字版权保护 \n  \n 这里介绍如何在Android 4.4及以上版本的设备上播放，DRM相关的媒体，用不到，略... \n  \n  \n  \n ## 支持的格式 \n  \n https://google.github.io/ExoPlayer/supported-formats.html \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n "}