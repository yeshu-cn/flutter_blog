{"title":"ExoPlayer1-使用","createTime":1510912692000,"updateTime":-1,"category":"default","content":" \n  \n # ExoPlayer1-使用 \n  \n https://google.github.io/ExoPlayer/guide-v1.html \n  \n 三个重要的概念：`TrackRenderer`,`SampleSource`,`DataSource` \n  \n ## TrackRenderer \n  \n * `TrackRenderer`负责播放指定类型的媒体如视频，音频或文字。 \n * `MediaCodecVideoTrackRenderer` 是负责播放视频的实现 \n * `MediaCodecAudioTrackRenderer` 是负责播放音频的实现 \n * `TextTrackRenderer` 负责显示文字 \n  \n `MediaCodecVidoTrackRenderer`和`MediaCodecAudioTrackRenderer`都是利用Android的`MediaCodec`类实现解码数据（支持的格式：https://developer.android.com/guide/appendix/media-formats.html） \n  \n ExoPlayer使用一般流程 \n  \n ``` \n // 1. Instantiate the player. \n player = ExoPlayer.Factory.newInstance(RENDERER_COUNT); \n // 2. Construct renderers. \n MediaCodecVideoTrackRenderer videoRenderer = ... \n MediaCodecAudioTrackRenderer audioRenderer = ... \n // 3. Inject the renderers through prepare. \n player.prepare(videoRenderer, audioRenderer); \n // 4. Pass the surface to the video renderer. \n player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface); \n // 5. Start playback. \n player.setPlayWhenReady(true); \n ... \n player.release(); // Don’t forget to release when done! \n  \n ``` \n  \n ## SampleSource \n  \n `TrackRender`的构造函数需要传入一个`SampleSource`实例，`SampleSource`负责提供媒体的数据信息和格式。ExoPlayer library中提供了几种不同格式数据的`SampleSource`实现:  \n  \n * `ExtractorSampleSource`- For formats such as FMP4,MP4,M4A,MKV,WebM,MP3,AAC,MPEG-TS,MPEG-PS,OGG,FLV and WAV \n * `ChunkSampleSource` - For DASH \tand SmoothStreaming playbacks. \n * `HlsSampleSource` - For HLS playbacks \n  \n  \n ## DataSource \n   \n  负责给`SampleSource`加载媒体数据，最常见的实现有： \n   \n  * `DefaultUriDataSource` - For playing media that can be either local or loaded over the network \n  * `AssetDataSource` - For playing media stored in the `assets` folder of application's apk \n  * `ChunkSource` - For DASH, 加载并提供媒体数据块 \n  \n   \n ## 传统媒体的播放流程 （Traditional media playbacks） \n   \n  传统媒体就是指：FMP4, MP4, M4A, MKV, WebM, MP3, AAC, MPEG-TS, MPEG-PS, OGG, FLV and WAV.  \n   \n  ```java \n Allocator allocator = new DefaultAllocator(BUFFER_SEGMENT_SIZE); \n DataSource dataSource = new DefaultUriDataSource(context, null, userAgent); \n ExtractorSampleSource sampleSource = new ExtractorSampleSource( \n     \turi, dataSource, allocator, BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE); \n MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer( \n     \tcontext, sampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT); \n MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer( \n     \tsampleSource, MediaCodecSelector.DEFAULT); \n  ``` \n   \n ## 自适应媒体播放 （Adaptive media playbacks） \n 就是直播视频，选择视频清晰度的技术 \n   \n > 自适应流媒体技术，就是能够智能感知你的下载速度，然后动态调节视频的编码速率，为你提供最高质量、最平滑的视频演播的技术。 [detail](https://zhidao.baidu.com/question/2117519251785432747.html) \n  \n 常见的技术方案有 \n  \n  * 苹果的HLS \n  * 微软的Microsoft Smooth Streaming(SmoothStreaming) \n  * 国际标准DASH \n  \n #### DASH and SmoothStreaming \n  \n `ChunkSampleSource`构造函数需要传入`ChunkSource`和`LoadControl`。`ChuckSource` providing media chunks from which to load and read samples.  有如下两种实现 \n  \n * `DashChunkSource`：provides DASH playback using the FMP4 and WebM container formats \n * `SmoothStreamingChunkSource`：provides SmoothStreaming playback using the FMP4 container format. \n  \n `ChunkSource`的实现类需要传入`FormatEvaluator`和`DataSource` \n  \n * `FormatEvaluator`负责管理使用的格式 \n * `DataSource`负责提供数据 \n * `LoadControl`负责处理缓冲策略 \n  \n ```java \n LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE)); \n DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(); \n  \n // Build the video renderer. \n DataSource videoDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent); \n ChunkSource videoChunkSource = new DashChunkSource(manifestFetcher, \n     DefaultDashTrackSelector.newVideoInstance(context, true, false), videoDataSource, \n     new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset, null, null, \n     DemoPlayer.TYPE_VIDEO); \n ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl, \n     VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE); \n MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context, \n     videoSampleSource, MediaCodecSelector.DEFAULT, \n     MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT); \n  \n // Build the audio renderer. \n DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent); \n ChunkSource audioChunkSource = new DashChunkSource(manifestFetcher, \n     DefaultDashTrackSelector.newAudioInstance(), audioDataSource, null, LIVE_EDGE_LATENCY_MS, \n     elapsedRealtimeOffset, null, null, DemoPlayer.TYPE_AUDIO); \n ChunkSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, \n     loadControl, AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE); \n MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer( \n     audioSampleSource, MediaCodecSelector.DEFAULT); \n  \n ``` \n  \n > In this code, `manifestFetcher` is an object responsible for loading the DASH manifest that defines the media. The `videoAdaptationSetIndex` and `audioAdaptationSetIndex` variables index components of the initially loaded manifest that correspond to video and audio respectively. \n  \n  \n  \n ### HLS \n  \n HLS播放需要使用到`HlsSampleSource`,`HlsChunkSource` \n  \n example: \n  \n ```java \n LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE)); \n DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(); \n PtsTimestampAdjusterProvider timestampAdjusterProvider = new PtsTimestampAdjusterProvider(); \n DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent); \n HlsChunkSource chunkSource = new HlsChunkSource(true /* isMaster */, dataSource, url, manifest, \n     DefaultHlsTrackSelector.newDefaultInstance(context), bandwidthMeter, timestampAdjusterProvider, \n     HlsChunkSource.ADAPTIVE_MODE_SPLICE); \n HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, loadControl, \n     MAIN_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE); \n MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context, sampleSource, \n     MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT); \n MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource, \n     MediaCodecSelector.DEFAULT); \n  \n ``` \n  \n ## notes \n  \n 好像只有自适应媒体的播放才有`loadControl`控制缓冲策略，传统媒体都是直接播放 \n  \n [视频播放的相关协议](https://www.zhihu.com/collection/200537456)"}