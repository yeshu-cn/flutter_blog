{"title":"大话设计模式笔记","createTime":1441491175000,"updateTime":1441491305000,"category":"default","content":" \n  \n ##大话设计模式笔记 \n * 24种设计模式，4大原则 \n * 简单工厂模式和策略模式很像 \n * 工厂模式是简单工厂的改进版 \n * 开源项目二次开发时，可以利用装饰模式添加新功能 \n * 浏览器中用代理模式来优化下载 \n * 原型模式就是Java里面的clone()方法 \n  \n  \n ###1.简单工厂模式 \n ```c++ \n //优点：核心是工厂类，这个类负责产品的创建，而客户端可以免去产品创建的责任，实现了责任的分割。 \n //缺点：工厂类集中了所有产品的创建逻辑，如果增加新的产品必须修改工厂角色的源码。 \n public class OperationFactory \n { \n \tpublic static Operation createOperate(string operate) \n \t{ \n \t\tOperation oper = null; \n \t\tswitch(operate) \n \t\t{ \n \t\t\tcase \"+\": \n \t\t\t\toper = new OperationAdd(); \n \t\t\t\tbreak; \n \t\t\tcase \"-\": \n \t\t\t\toper = new OperationSub(); \n \t\t\t\tbreak; \n \t\t\tcase \"*\": \n \t\t\t\toper = new OperationMul(); \n \t\t\t\tbreak; \n \t\t\tcase \"/\" \n \t\t\t\toper = new OperationDiv(); \n \t\t\t\tbreak; \n \t\t} \n \t\t \n \t\treturn oper; \n \t} \n } \n  \n //使用 \n Operation oper; \n oper = OperationFactory.createOperate(\"+\"); \n oper.NumberA = 1; \n oper.NumberB = 2; \n double result = oper.GetResult(); \n  \n ``` \n  \n ###2.策略模式 \n ```c++ \n  \n //策略模式就是用来封装一系列的算法. \n //用户使用工厂模式产生算法，在通过CashContext类直接使用算法。 \n class CashContext \n { \n \tCashSuper cs = null; \n \tpublic CashSuper(String type) \n \t{ \n \t\tcase \"正常收费\": \n \t\t\tCashNormal cs0 = new CashNormal(); \n \t\t\tcs = cs0; \n \t\t\tbreak; \n \t\tcase \"满300烦100\": \n \t\t\tCashReturn cr1 = new CashReturn(\"300\", \"100\"); \n \t\t\tcs = cs1; \n \t\t\tbreak; \n \t\tcase \"打8折\": \n \t\t\tCashRebate cr2 = new CashRebate(\"0.8\"); \n \t\t\tbreak; \n \t} \n \t \n \tpublic double GetResult(double money) \n \t{ \n \t\treturn cs.acceptCash(money); \n \t} \n } \n  \n //使用 \n CashContext csuper = new CashContext(\"正常收费\"); \n double price = csuper.GetResult(100d); \n  \n ``` \n  \n ###3.装饰模式 \n `动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。` \n  \n  \n ```c++ \n abstract class Component \n { \n \tpublic abstract void Operation(); \n } \n  \n class ConcreteComponent : Component \n { \n \tpublic override void Operation() \n \t{ \n \t\t \n \t} \n } \n  \n abstract class Decorator : Component \n { \n \tprotected Component component; \n \t \n \tpublic void SetComponent(Component component) \n \t{ \n \t\tthis.component = component; \n \t} \n \t \n \tpublic override void Operation() \n \t{ \n \t\tif(null != component) \n \t\t{ \n \t\t\tcomponent.Operation(); \n \t\t} \n \t} \n } \n  \n //使用 \n ConcreteComponent c = new ConcreteComponent(); \n ConcreteDecoratorA d1 = new ConcreteDecoratorA(); \n ConcreteDecoratorB d2 = new ConcreteDecoratorB(); \n  \n //装饰 \n d1.SetComponent(c); \n d2.SetComponent(d1); \n //执行操作 \n d2.Operation(); \n  \n ``` \n  \n ###4.代理模式 \n ```c++ \n abstract class Subject \n { \n \tpublic abstract void Request(); \n } \n  \n class RealSubject : Subject \n { \n \tpublic override void Request() \n \t{ \n \t \n \t} \n } \n  \n class Proxy : Subject \n { \n \tRealSubject realSubject = new RealSubject(); \n \tpublic override void Request() \n \t{ \n \t\trealSubject.Requst(); \n \t} \n } \n  \n //客户端使用 \n Proxy proxy = new Proxy(); \n proxy.Request(); \n ``` \n  \n ###5.工厂方法模式 \n `克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。` \n  \n ```c++ \n //工厂抽象类 \n interface IFactory \n { \n \tLeiFeng CreateLeiFeng(); \n } \n //两个工厂子类 \n class UndergraduateFactory : IFactory \n { \n \tpublic LeiFeng CreateLeiFeng() \n \t{ \n \t \n \t} \n } \n  \n class VolunteerFactory : IFactory \n { \n \tpublic LeiFeng CreanteLeiFeng() \n \t{ \n \t \n \t} \n } \n  \n //客户端决定使用哪个工厂 \n IFactory factory = new UndergraduateFactory(); \n LeiFeng student = factory.CreateLeiFeng(); \n ``` \n ###6.原型模式 \n  \n ```c++ \n //使用场景：一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这即隐藏了对象的创建细节，又对性能是大大的提高 \n abstract class Prototype \n { \n \tprivate String id; \n \tpublic Prototype(string id) \n \t{ \n \t\tthis.id = id; \n \t} \n \t \n \tpublic string id \n \t{ \n \t\tget { return id; } \n \t} \n \t \n \tpublic abstract Prototype Clone() \n \t{ \n \t \n \t} \n } \n  \n //具体的原型类 \n class ContretePrototype : Prototype \n { \n \tpublic ConcretePrototype(string id) : base(id) \n \t{ \n \t \n \t} \n \t \n \tpublic override Prototype Clone() \n \t{ \n \t\t//针对引用遍历需要深拷贝 \n \t} \n } \n  \n //客户端使用 \n ConcretePrototype p1 = new ConcretePrototype(\"I\"); \n ConcretePrototype p2 = (ConcretePrototype)p1.Clone(); \n ``` \n ###7.模板方法模式 \n  \n ###8.外观模式 \n  \n ###9.建造者模式 \n  \n ###10.观察者模式 \n  \n ###11.抽象工厂模式 \n  \n ###12.状态模式 \n  \n ###13.适配器模式 \n  \n ###14.备忘录模式 \n  \n ###15.组合模式 \n  \n ###16.迭代器模式 \n  \n ###17.单例模式 \n  \n ###18.桥接模式 \n  \n ###19.命令模式 \n  \n ###20.职责链模式 \n  \n ###21.中介者模式 \n  \n ###22.享元模式 \n  \n ###23.解释器模式 \n  \n ###24.访问者模式 \n  \n ###单一职责原则 \n `就一个类而言，应该仅有一个引起它变化的原因` \n  \n * 发现职责并把哪些职责相互分离 \n * 如果你能想到多于一个动机去改变一个类，那么这个类就具有多于一个的职责 \n  \n ###开放-封闭原则 \n `是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改。对于扩展是开放的，对于更改是封闭的` \n  \n * 面对需求，对程序的改动是通过增加新的代码进行的，而不是更改现有的代码 \n * 猜测出最有可能发生变化的种类，然后构造出抽象来隔离那些变化 \n  \n ###依赖倒转原则 \n ` \n A. 高层模块不应该依赖底层模块。两个都应该依赖抽象 \n B. 抽象不应该依赖细节。细节应该依赖抽象 ` \n  \n * 针对接口编程，不要针对实现编程 \n * 里氏代换原则：子类型必须能够替换掉他们的父类型。 \n  \n ###迪米特法则 \n  \n ###模式总结 \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n "}