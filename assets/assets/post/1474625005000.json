{"title":"Java WeakHashMap 不会自动释放Value","createTime":1474625005000,"updateTime":-1,"category":"default","content":" \n  \n  \n  \n WeakHashMap中只有key才是WeakReference,可以被gc自动回收，但是Value是强引用，需要调用get/put方法才会触发回收 \n  \n  \n  \n  \n > 1. 如果构造函数中指定了ReferenceQueue，那么事后程序员可以通过该队列清理引用 \n > 2. 如果构造函数中没有指定了ReferenceQueue，那么 GC 会自动清理引用 \n > 3. 当弱引用指向的对象只能通过弱引用（没有强引用或弱引用）访问时，GC会清理掉该对象，之后，引用对象会被放到ReferenceQueue中 \n  \n 参考：[Java WeakHashMap源码解析](http://liujiacai.net/blog/2015/09/27/java-weakhashmap/) 写的很详细 \n  \n ```java \n public class WeakReference<T> extends Reference<T> { \n  \n     public WeakReference(T r) { \n         super(r, null); \n     } \n  \n \t//q是用来指向自己的，让gc清理“引用”这个对象 \n     public WeakReference(T r, ReferenceQueue<? super T> q) { \n         super(r, q); \n     } \n } \n ``` \n  \n Entry对象是个引用对象 \n  \n ```java \n public class WeakHashMap<K, V> extends AbstractMap<K, V> implements Map<K, V> { \n \tprivate final ReferenceQueue<K> referenceQueue; \n \t \n \tprivate static final class Entry<K, V> extends WeakReference<K> implements Map.Entry<K, V> { \n \t\tEntry(K key, V object, ReferenceQueue<K> queue) { \n \t\t\t//只有 key是weakReference \n \t\t\tsuper(key, queue); \n \t\t\t//... \n \t\t} \n \t} \n \t \n \t//... \n } \n ``` \n  \n  \n  \n  \n  \n ```java \n public V put(K key, V value) { \n \t\t//这个函数中处理了referenceQueuqe中对象的手动删除 \n         poll(); \n         int index = 0; \n         Entry<K, V> entry; \n \t\t \n \t\t//... \n         if (entry == null) { \n             modCount++; \n             if (++elementCount > threshold) { \n                 rehash(); \n                 index = key == null ? 0 : (Collections.secondaryHash(key) & 0x7FFFFFFF) \n                         % elementData.length; \n             } \n             //实例化Entry时，传入了referenceQueue,所以该Entry对象需要自己手动释放 \n             entry = new Entry<K, V>(key, value, referenceQueue); \n             entry.next = elementData[index]; \n             elementData[index] = entry; \n             return null; \n         } \n         V result = entry.value; \n         entry.value = value; \n         return result; \n     } \n ``` \n  \n  \n 删除referenceQueue中的无效的Entry,释放内存空间 \n  \n ``` \n void poll() { \n         Entry<K, V> toRemove; \n         while ((toRemove = (Entry<K, V>) referenceQueue.poll()) != null) { \n             removeEntry(toRemove); \n         } \n     } \n ``` \n  \n  \n "}