{"title":"LiveData笔记","createTime":1527838778000,"updateTime":-1,"category":"default","content":" \n  \n  \n # LiveData \n  \n 原来LiveData只要调用setValue就会回调onChange(),不关心数据值是否真的发生变化了。不过会关心observer的state \n  \n from:https://developer.android.com/topic/libraries/architecture/livedata \n  \n * LiveData是一个可被监听其中数据变化的Observer \n * LiveData is lifecycle-aware,知道组件的生命周期变化 \n * LiveData只会在`active lifecycle state`状态才会触发数据变化的回调 \n * `activite lifecycle state`是指在lifecycle的`STARTED`和`RESUMED`状态之间 \n * LiveData会在`LifeCycle`状态变化为`DESTORYED`时，removed掉observer \n  \n  \n ## LiveData优点 \n  \n * 观察者模式确保数据和UI显示一致 \n * Lifecycle机制自动注销observer,确保不会内存泄漏 \n * UI不可见的时候不会更新界面，减少由此触发的程序崩溃 \n * 不用在自己处理生命周期相关的业务了(no more manual lifecycle handling) \n * UI总会在回到前台时获取到最新的数据（always up to date data） \n * 配置变化导致UI重建时，UI能收到最新的可用数据，恢复界面 \n * Fragment,Activity,Servie间共享数据 \n  \n ## LiveData使用 \n  \n * 创建LiveData对象 \n * 创建Observer对象，实现onChanged()方法 \n * 通过LiveData.observer()方法注册监听 \n  \n ### 创建LiveData对象 \n  \n ```java \n public class NameViewModel extends ViewModel { \n  \n // Create a LiveData with a String \n private MutableLiveData<String> mCurrentName; \n  \n     public MutableLiveData<String> getCurrentName() { \n         if (mCurrentName == null) { \n             mCurrentName = new MutableLiveData<String>(); \n         } \n         return mCurrentName; \n     } \n  \n // Rest of the ViewModel... \n } \n ``` \n  \n LiveData放在ViewModel中，不放在Activity,Frgment中的原因 \n  \n * 避免和activities,fragments产生依赖，ui只需要负责展示数据，而不必关心数据状态 \n * 和activities,fragments脱钩，让LiveData可以在配置发生变化时依然可用 \n  \n ### Observe LiveData objects \n  \n 回调时机 \n  \n * LiveData中的数据发生变化 \n * Observer的状态由inactive变化成了activie state时,仅仅只在第一次的时候。后面状态变化不会再触发了 \n * 如果LiveData中没有设置数据，不会触发回调 \n  \n  \n ```java \n public class NameActivity extends AppCompatActivity { \n  \n     private NameViewModel mModel; \n  \n     @Override \n     protected void onCreate(Bundle savedInstanceState) { \n         super.onCreate(savedInstanceState); \n  \n         // Other code to setup the activity... \n  \n         // Get the ViewModel. \n         mModel = ViewModelProviders.of(this).get(NameViewModel.class); \n  \n  \n         // Create the observer which updates the UI. \n         final Observer<String> nameObserver = new Observer<String>() { \n             @Override \n             public void onChanged(@Nullable final String newName) { \n                 // Update the UI, in this case, a TextView. \n                 mNameTextView.setText(newName); \n             } \n         }; \n  \n         // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. \n         mModel.getCurrentName().observe(this, nameObserver); \n     } \n } \n ``` \n  \n ### Update LiveData objects \n  \n * MutableLiveData使用setValue(T),postValue(T)方法更新数据 \n  \n ```java \n mButton.setOnClickListener(new OnClickListener() { \n     @Override \n     public void onClick(View v) { \n         String anotherName = \"John Doe\"; \n         mModel.getCurrentName().setValue(anotherName); \n     } \n }); \n  \n ``` \n  \n ### Use LiveData with Room \n  \n ## Extend LiveData \n  \n ```java \n public class StockLiveData extends LiveData<BigDecimal> { \n     private StockManager mStockManager; \n  \n     private SimplePriceListener mListener = new SimplePriceListener() { \n         @Override \n         public void onPriceChanged(BigDecimal price) { \n             setValue(price); \n         } \n     }; \n  \n     public StockLiveData(String symbol) { \n         mStockManager = new StockManager(symbol); \n     } \n  \n     @Override \n     protected void onActive() { \n         mStockManager.requestPriceUpdates(mListener); \n     } \n  \n     @Override \n     protected void onInactive() { \n         mStockManager.removeUpdates(mListener); \n     } \n } \n  \n ``` \n  \n LiveData监听回调关系 \n  \n * If the `Lifecycle` object is not in an activity state. then the observer isn't called even if the value changes. \n * After the `Lifecycle` object is destroyed, the observer is auotmatically removed; \n  \n 在多个Activity,Fragment,Service之间共享LiveData数据 \n  \n ```java \n public class StockLiveData extends LiveData<BigDecimal> { \n     private static StockLiveData sInstance; \n     private StockManager mStockManager; \n  \n     private SimplePriceListener mListener = new SimplePriceListener() { \n         @Override \n         public void onPriceChanged(BigDecimal price) { \n             setValue(price); \n         } \n     }; \n  \n     @MainThread \n     public static StockLiveData get(String symbol) { \n         if (sInstance == null) { \n             sInstance = new StockLiveData(symbol); \n         } \n         return sInstance; \n     } \n  \n     private StockLiveData(String symbol) { \n         mStockManager = new StockManager(symbol); \n     } \n  \n     @Override \n     protected void onActive() { \n         mStockManager.requestPriceUpdates(mListener); \n     } \n  \n     @Override \n     protected void onInactive() { \n         mStockManager.removeUpdates(mListener); \n     } \n } \n ``` \n  \n use is as follow \n  \n ```java \n public class MyFragment extends Fragment { \n     @Override \n     public void onActivityCreated(Bundle savedInstanceState) { \n         StockLiveData.get(getActivity()).observe(this, price -> { \n             // Update the UI. \n         }); \n     } \n } \n  \n ``` \n  \n ## Transform LiveData \n  \n 将LiveData中的数据转换为observer中想要的数据类型 \n  \n ```java \n LiveData<User> userLiveData = ...; \n LiveData<String> userName = Transformations.map(userLiveData, user -> { \n     user.name + \" \" + user.lastName \n }); \n  \n ``` \n  \n ```java \n private LiveData<User> getUser(String id) { \n   ...; \n } \n  \n LiveData<String> userId = ...; \n LiveData<User> user = Transformations.switchMap(userId, id -> getUser(id) ); \n ``` \n  \n ## Merge multiple LiveData sources \n  \n 使用`MediatorLiveData`聚合多个LiveData \n  \n  \n  \n  \n  \n "}