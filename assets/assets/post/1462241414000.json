{"title":"View的滑动，移动相关方法","createTime":1462241414000,"updateTime":1462923365000,"category":"default","content":" \n  \n **移动View的方法：** \n  \n ```java \n view.layout(mOriLeft, mOriTop, mOriRight, mOriBottom);  \n ``` \n  \n **view的内容移动流程** \n  \n `scrollTo()`/`scrllBy()`—>`invalidate()`/`postInvalidate()`——>`computeScroll()`; \n  \n  \n **Scroller只是用来计算合适的滑动坐标** \n  \n  \n ```java \n \t@Override   \n    public void computeScroll() {   \n         \n          //先判断mScroller滚动是否完成   \n          if (mScroller.computeScrollOffset()) {   \n             \n              //这里调用View的scrollTo()完成实际的滚动   \n              scrollTo(mScroller.getCurrX(), mScroller.getCurrY());   \n                 \n              //必须调用该方法，否则不一定能看到滚动效果   \n              postInvalidate();   \n         }   \n          super.computeScroll();   \n \t} \n ``` \n  \n  \n **Scroller使用：** \n  \n 1. `scroller = new Scroller(Context)` \n 2. 调用`Scroller.startScroll()`或者`Scroller.fliing()`; \n 3. 调用`invalidate()`确保回调`computeScroll()`方法 \n 4. 复写`computeScroll()`,并在其中调用`view.scrollTo`/`view.scrollBy` \n 5. 调用`invalidate()`确保刷新界面 \n  \n **VelocityTracker使用** \n  \n 1. `mVelocityTracker = VelocityTracker.obtain()`;使用`obtain()`方法获取实例 \n 2. 调用`addMovement(Motion Event)`函数将`Motion event` 加入到`VelocityTracker`类中 \n 3. 调用`computeCurrentVelocity(int)`来初始化速率单位 \n 4. 调用`getXVelocity()`或`getYVelocity()`来获取速率 \n  \n  \n **overScrollBy使用** \n  \n 1. 调用`overScrollBy`，计算需要滑动的x,y坐标和是否`clamped`（滑到顶端了） \n 2. `overScrollBy`会回调`onOverScrolled`方法 \n 3. 复写`onOverScrolled`方法执行真正的继续滑动，或者回弹 \n  \n 总结： \n  \n 1. `Scroller`使用，必须配合`computeScroll`来执行真正的滑动 \n 2. `overScrollBy`使用，必须配合`onOverScrolled`来执行真正的滑动 \n  \n `computeScroll()`和`onOverScrolled()`默认都是空函数，等着用户来复写 \n  \n **函数参数详解：** \n  \n ```java \n protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) \n  \n private int mOverScrollDistance = 100; \n //横向滑动 \n overScrollBy(deltaX, 0, (int)scrollX, getScrollY(), getScrollRangeX(), 0, mOverScrollDistance, 0, true); \n  \n public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY, int overX, int overY)  \n  \n private int mOverflingDistance = 50; \n //横向滑动 \n mScroller.fling(getScrollX(), getScrollY(), velocityX, 0, 0, getScrollRangeX(), 0, 0, mOverflingDistance, 0); \n  \n //横向回弹效果 \n public boolean springBack(int startX, int startY, int minX, int maxX, int minY, int maxY) \n mScroller.springBack(getScrollX(), getScrollY(), 0, getScrollRangeX(), 0, 0))  \n  \n  \n //处理多点触碰的干扰 \n //获取触碰点id \n mActivePointerId = event.getPointerId(0); \n  \n //获取触碰点x坐标 \n final int activePointerIndex = event.findPointerIndex(mActivePointerId); \n float x = event.getX(activePointerIndex); \n  \n //获取触碰点velocity \n int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId); \n ``` \n  \n 资料：<http://www.eoeandroid.com/thread-553375-1-9.html?_dsign=404ec396> \n 将文章中的Demo运行一下就非常清楚了"}