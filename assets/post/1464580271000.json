{"title":"HashMap源码笔记","createTime":1464580271000,"updateTime":1464651760000,"category":"default","content":" \n  \n  \n 数组：寻址容易，插入和删除困难 \n  \n 链表：寻址困难，插入和删除容易 \n  \n HashMap:寻址容易，插入和删除也容易 \n  \n 实现原理:数组+链表的方式实现快速读取和修改 \n  \n ```java \n     public V put(K key, V value) { \n         if (table == EMPTY_TABLE) { \n             inflateTable(threshold); \n         } \n         if (key == null) \n             return putForNullKey(value); \n         int hash = hash(key); \n         //通过hash快速计算得到数组的index \n         int i = indexFor(hash, table.length); \n         for (Entry<K,V> e = table[i]; e != null; e = e.next) { \n             Object k; \n             if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { \n                 V oldValue = e.value; \n                 e.value = value; \n                 e.recordAccess(this); \n                 return oldValue; \n             } \n         } \n  \n         modCount++; \n         addEntry(hash, key, value, i); \n         return null; \n     } \n ``` \n  \n ```java \n     final Entry<K,V> getEntry(Object key) { \n         if (size == 0) { \n             return null; \n         } \n  \n         int hash = (key == null) ? 0 : hash(key); \n         //e = e.next,处理hash冲突时遍历链表获取值，叫链地址法 \n         for (Entry<K,V> e = table[indexFor(hash, table.length)]; \n              e != null; \n              e = e.next) { \n             Object k; \n             if (e.hash == hash && \n                 ((k = e.key) == key || (key != null && key.equals(k)))) \n                 return e; \n         } \n         return null; \n     } \n ``` \n  \n 这两个函数就是将key转换为index的地方 \n  \n     其中h是hash值，length是数组的长度，这个按位与的算法其实就是h%length求余，一般什么情况下利用该算法，典型的分组。例如怎么将100个数分组16组中，就是这个意思。应用非常广泛。 \n  \n ```java \n     final int hash(Object k) { \n         int h = hashSeed; \n         if (0 != h && k instanceof String) { \n             return sun.misc.Hashing.stringHash32((String) k); \n         } \n  \n         h ^= k.hashCode(); \n         h ^= (h >>> 20) ^ (h >>> 12); \n         return h ^ (h >>> 7) ^ (h >>> 4); \n     } \n  \n  \n     static int indexFor(int h, int length) { \n         return h & (length-1); \n     } \n ``` \n  \n hash冲突的解决方法 \n 1. 开放定址法 \n 2. 再哈希法 \n 3. 链地址法 \n 4. 建立一 公共溢出区 \n  \n  \n 使用注意 \n  \n * HashMap存在一个默认75%的负载因子，当容量超过负载因子时会resize。resize会重新计算各个元素的索引。所以最好初始化时就声明好大小。 \n * Android中在数据量不大的情况下可以用`SparseArray`,`ArrayMap`代替，它们能节省内存空间。  \n  \n  \n `SparseArray`,`ArrayMap`优点：节省内存空间，用到了二分查找，避免了自动装箱。 \n  \n ```java \n     static int binarySearch(int[] array, int size, int value) { \n         int lo = 0; \n         int hi = size - 1; \n  \n         while (lo <= hi) { \n             final int mid = (lo + hi) >>> 1; \n             final int midVal = array[mid]; \n  \n             if (midVal < value) { \n                 lo = mid + 1; \n             } else if (midVal > value) { \n                 hi = mid - 1; \n             } else { \n                 return mid;  // value found \n             } \n         } \n         return ~lo;  // value not present \n     } \n ``` \n  \n 资料 \n  \n * http://www.jianshu.com/p/8b372f3a195d \n * http://blog.csdn.net/lcore/article/details/8885961"}