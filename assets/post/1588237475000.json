{"title":"Coroutines使用","createTime":1588237475000,"updateTime":-1,"category":"Android","content":" \n  \n ## Android上为什么使用Coroutines \n * 方便的管理长时间运行的任务 \n * 提供`main-safe`的方法，主线程可以安全调用的方法、 \n  \n ## Coroutines使用     \n  \n ```kotlin \n // Dispatchers.Main \n suspend fun fetchDocs() { \n     // Dispatchers.Main \n     val result = get(\"developer.android.com\") \n     // Dispatchers.Main \n     show(result) \n } \n // Dispatchers.Main \n suspend fun get(url: String) = \n     // Dispatchers.Main \n     withContext(Dispatchers.IO) { \n         // Dispatchers.IO \n         /* perform blocking network IO here */ \n     } \n     // Dispatchers.Main \n ``` \n  \n > Well written suspend functions are always safe to call from the main thread (or main-safe). \n  \n 使用`withContext`来实现`main-safe`的方法，`withContext`有性能优势，即使多次调用也可以避免线程的切换开销 \n  \n 三个调度器 \n * Dispatchers.IO （执行网络或IO操作） \n * Dispatchers.Default (适合执行占用大量CPU资源的工作，例如排序、解析JSON等) \n * Dispatchers.Main (主线程) \n  \n ### scope的来源 \n suspend方法必须在scope中启动，可以是GlobalScope, viewModelScope或者实现CoroutineScope接口。 \n  \n ```kotlin \n class MyActivity : AppCompatActivity(), CoroutineScope by MainScope() { \n     override fun onDestroy() { \n         // cancel is extension on CoroutineScope \n         cancel()  \n     } \n  \n     /* \n      * Note how coroutine builders are scoped: if activity is destroyed or any of the launched coroutines \n      * in this method throws an exception, then all nested coroutines are cancelled. \n      */ \n         fun showSomeData() = launch { // <- extension on current activity, launched in the main thread \n            // ... here we can use suspending functions or coroutine builders with other dispatchers \n            draw(data) // draw in the main thread \n         } \n     } \n ``` \n  \n ### structured concurrency管理协程 \n > A leaked coroutine can waste memory, CPU, disk, or even launch a network request that’s not needed. \n  \n 没有妥善管理好生命周期的协程，可能会造成资源的浪费。所以Kotlin提供了`structured concurreny`来管理协程的运行和生命周期。 \n  \n 通过`structured concurrency`提供如下能力： \n * When a **scope cancels**, all of its **coroutines cancel**. \n * When a **suspend fun returns**, all of its **work is done**. \n * When a **coroutine errors**, its **caller or scope is notified**. \n  \n `coroutines`必须运行在`CoroutineScope`中，`CoroutineScope`就是用来追踪管理所有的`coroutines`。 \n  \n > A CoroutineScope keeps track of all your coroutines, and it can cancel all of the coroutines started in it. \n  \n ### CoroutineScope启动coroutines的两种方式 \n * `launch`:只负责启动，不会返回任何结果 \n * `async`:启动并返回一个结果，调用`await`获取返回值 \n  \n ```kotlin \n scope.launch { \n     // This block starts a new coroutine  \n     // \"in\" the scope. \n     //  \n     // It can call suspend functions \n    fetchDocs() \n } \n ``` \n 注意：`launch`启动的协程会跑出异常，`async`则不会，因为它设计的初衷时通过`await`方法取得结果或异常。 \n  \n  \n ### 并发处理 \n `suspend functions`中使用`coroutineScope`或者`supervisorScope`来同时启动多个协程。 \n  \n `coroutineScope`可以保证当`suspend`方法返回时，它里面的所有协程都已经执行完毕。 \n  \n > Structured concurrency guarantees that when a suspend function returns, all of its work is done. \n  \n  \n ```kotlin \n suspend fun fetchTwoDocs() { \n     coroutineScope { \n         launch { fetchDoc(1) } \n         async { fetchDoc(2) } \n     } \n } \n ``` \n * `coroutinesScope`：当其中一个协程失败时，会取消它所启动的所有协程 \n * `supervisorScope`：当其中一个协程失败时，不会影响它所启动的其他协程 \n  \n ### 异常错误处理 \n 通过`try/catch`不错错误异常 \n  \n 通过async启动协程可能会丢失异常 \n ```kotlin \n val unrelatedScope = MainScope() \n // example of a lost error \n suspend fun lostError() { \n     // async without structured concurrency \n     unrelatedScope.async { \n         throw InAsyncNoOneCanHearYou(\"except\") \n     } \n } \n ``` \n `async`设计初衷是假设您会通过`await`来获取结果或异常，但是如果你没有调用它，就会造成异常丢失。 \n  \n > Structured concurrency guarantees that when a coroutine errors, its caller or scope is notified. \n  \n 但是通过`structured concurrency`可以确保怎么也不会丢失异常 \n  \n ```kotlin \n suspend fun foundError() { \n     coroutineScope { \n         async {  \n             throw StructuredConcurrencyWill(\"throw\") \n         } \n     } \n } \n ``` \n ### ViewModel中启动coroutines \n > Structured concurrency guarantees when a scope cancels, all of its coroutines cancel. \n  \n 取消`scope`会取消它里面的所有协程。 \n  \n 使用`viewModelScope`需要倒入依赖`lifecycle-viewmodel-ktx:2.1.0-alpha04`。 \n  \n ``` \n class MyViewModel(): ViewModel() { \n     fun userNeedsDocs() { \n         // Start a new coroutine in a ViewModel \n         viewModelScope.launch { \n             fetchDocs() \n         } \n     } \n } \n ``` \n  \n `viewModelScope`会在生命周期结束时(onCleared()调用时)自动取消里面的所有协程，所以即使如下代码也是安全的。 \n  \n ``` \n fun runForever() { \n     // start a new coroutine in the ViewModel \n     viewModelScope.launch { \n         // cancelled when the ViewModel is cleared \n         while(true) { \n             delay(1_000) \n             // do something every second \n         } \n     } \n } \n ``` \n ### Room中使用Coroutines \n  \n > Note: Room uses its own dispatcher to run queries on a background thread. Your code should not use withContext(Dispatchers.IO) to call suspending room queries. It will complicate the code and make your queries run slower. \n  \n 1. 添加依赖 \n ``` \n //Kotlin Extensions and Coroutines support for Room \n implementation \"androidx.room:room-ktx:$room_version\" \n ``` \n 2. 在方法前加上`suspend` \n ```kotlin \n @Dao \n interface ProductsDao { \n    // Because this is marked suspend, Room will use it's own dispatcher \n    //  to run this query in a main-safe way. \n    @Query(\"select * from ProductListing ORDER BY dateStocked ASC\") \n    suspend fun loadProductsByDateStockedAscending(): List<ProductListing> \n  \n    // Because this is marked suspend, Room will use it's own dispatcher \n    //  to run this query in a main-safe way. \n    @Query(\"select * from ProductListing ORDER BY dateStocked DESC\") \n    suspend fun loadProductsByDateStockedDescending(): List<ProductListing> \n }  \n ``` \n  \n ### 将Callback转换为Coroutines \n ```kotlin \n suspend fun execute(): MyResultType { \n     return suspendCoroutine<MyResultType> { continuation -> \n         myRepository.myRemoteCall() \n             .subscribeOn(Schedulers.io()) \n             .observeOn(AndroidSchedulers.mainThread()) \n             .subscribe( \n                 { result -> onSuccess(continuation, result) }, \n                 { throwable -> onError(continuation, throwable) }) \n     } \n } \n private fun onSuccess( \n     continuation: Continuation, \n     result: MyResultType) { \n     ... \n     continuation.resume(result) \n } \n private fun onError( \n     continuation: Continuation, \n     throwable: Throwable) { \n     ... \n     continuation.resumeWithException(throwable) \n } \n ``` \n ## 提供main-safe的接口方法 \n 最佳实践，每个层面的接口都是`main-safe`的方法 \n * WebApi \n * Dao \n * Repository \n * UseCase \n  \n ## Coroutines单元测试 \n 导入依赖：kotlinx-coroutines-test \n  \n 使用`runBlocking`或`runBlockingTest`测试 \n ```kotlin \n @Test \n fun whenRefreshTitleSuccess_insertsRows() = runBlockingTest { \n    val titleDao = TitleDaoFake(\"title\") \n    val subject = TitleRepository( \n            MainNetworkFake(\"OK\"), \n            titleDao \n    ) \n  \n    subject.refreshTitle() \n    Truth.assertThat(titleDao.nextInsertedOrNull()).isEqualTo(\"OK\") \n } \n  \n ``` \n  \n `runBlocking`和`runBlockingTest`区别(没看懂这两个东西作用和区别) \n > Important: The function runBlockingTest will always block the caller, just like a regular function call. The coroutine will run synchronously on the same thread. You should avoid `runBlocking` and `runBlockingTest` in your application code and prefer launch which returns immediately. \n > \n > `runBlockingTest` should only be used from tests as it executes coroutines in a test-controlled manner, while `runBlocking` can be used to provide blocking interfaces to coroutines. \n  \n  \n  \n ## 资料 \n * [协程使用官方介绍](https://developer.android.com/kotlin/coroutines) \n * [协程的使用介绍](https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb) \n * [codelabs](https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#9) \n "}