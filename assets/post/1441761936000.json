{"title":"android-async-http源码分析","createTime":1441761936000,"updateTime":1441762028000,"category":"default","content":" \n  \n  \n * 学习一些命名规则 \n * 程序设计方式 \n  \n ##功能特征 \n * 进行http请求，以回调的方式处理返回 \n * 非UI线程进行网络请求 \n * 使用线程池处理并发的资源请求 \n * GET/POST请求参数化 \n * 文件分段上传 \n * 体积小，90kb \n * 自动重试机制 \n * 自动对gizp进行解码 \n * 使用`JsonHttpResponseHandler`解析为json格式response \n * 使用`FileAsyncHttpResponseHandler`保存response为文件 \n * 支持cookie存储，存储在SharedPreferences中 \n * `BaseJsonHttpResponseHandler `中集成jackson、Gson等库 \n * 支持编码设置，不仅仅`UTF-8` \n  \n  \n  \n ##使用 \n  \n ```java \n AsyncHttpClient client = new AsyncHttpClient(); \n client.get(\"https://www.google.com\", new AsyncHttpResponseHandler() { \n  \n     @Override \n     public void onStart() { \n         // called before request is started \n     } \n  \n     @Override \n     public void onSuccess(int statusCode, Header[] headers, byte[] response) { \n         // called when response HTTP status is \"200 OK\" \n     } \n  \n     @Override \n     public void onFailure(int statusCode, Header[] headers, byte[] errorResponse, Throwable e) { \n         // called when response HTTP status is \"4XX\" (eg. 401, 403, 404) \n     } \n  \n     @Override \n     public void onRetry(int retryNo) { \n         // called when request is retried \n \t} \n }); \n ``` \n  \n 推荐编码方式 \n  \n ```java \n import com.loopj.android.http.*; \n  \n public class TwitterRestClient { \n   private static final String BASE_URL = \"https://api.twitter.com/1/\"; \n  \n   private static AsyncHttpClient client = new AsyncHttpClient(); \n  \n   public static void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) { \n       client.get(getAbsoluteUrl(url), params, responseHandler); \n   } \n  \n   public static void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) { \n       client.post(getAbsoluteUrl(url), params, responseHandler); \n   } \n  \n   private static String getAbsoluteUrl(String relativeUrl) { \n       return BASE_URL + relativeUrl; \n   } \n } \n ``` \n  \n 使用`PersistentCookieStore `持久化Cookies \n 使用`RequestParams `添加GET/POST请求参数 \n 使用`RequestParams `上传文件 \n 使用`FileAsyncHttpResponseHandler `下载二进制数据 \n  \n  \n  \n ##命名 \n * FileWrapper \n * StreamWrapper \n * makeRequest()； \n * makeRequestWithRetries()； \n  \n ##如何实现重试机制 \n  \n `RetryHandler` \n  \n ```java \n \t \n \tmakeRequest() \n \tmakeRequestWithRetries() \n \t \n \t//重试次数和重试间隔时间 \n     private final int maxRetries; \n     private final int retrySleepTimeMS; \n      \n     //出发重试时的场景 \n     static { \n         // Retry if the server dropped connection on us \n         exceptionWhitelist.add(NoHttpResponseException.class); \n         // retry-this, since it may happens as part of a Wi-Fi to 3G failover \n         exceptionWhitelist.add(UnknownHostException.class); \n         // retry-this, since it may happens as part of a Wi-Fi to 3G failover \n         exceptionWhitelist.add(SocketException.class); \n  \n         // never retry timeouts \n         exceptionBlacklist.add(InterruptedIOException.class); \n         // never retry SSL handshake failures \n         exceptionBlacklist.add(SSLException.class); \n     } \n      \n     //请求重试 \n     public boolean retryRequest(IOException exception, int executionCount, HttpContext context)； \n      \n     if (retry) { \n             // resend all idempotent requests \n             HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST); \n             if (currentReq == null) { \n                 return false; \n             } \n         } \n ``` \n  \n  \n ##如何实现解析回调 \n  \n ```java \n public interface ResponseHandlerInterface{} \n  \n //内部存在一个Handler用于发送处理消息 \n public abstract class AsyncHttpResponseHandler implements ResponseHandlerInterface{} \n  \n public abstract class TextHttpResponseHandler extends AsyncHttpResponseHandelr{} \n public abstract class BinaryHttpResponseHandler extends AsyncHttpResonseHandler{} \n public abstract class FileAsyncHttpResponseHandler extends AsyncHttpResponseHandler{} \n public abstract class DataAsyncHttpResponseHandler extends AsyncHttpResponseHandler{} \n  \n public class JsonHttpResponseHandler extends TextHttpResponseHandler{} \n public abstract class BaseJsonHttpResponseHandler<JSON_TYPE> extends TextHttpResponseHandler{} \n  \n ``` \n  \n ###AsyncHttpResponseHandler构造函数 \n * 没有传入参数`Looper`则获取当前线程的`Looper`。一般使用情况下即为UI线程 \n * 创建一个静态内部类`ResponseHandler`与此`Looper`关联，并将消息委托给`AsyncHttpResponseHandler`实例的`handleMessage`函数来处理 \n  \n  \n  \n ##如何管理网络请求 \n  \n * AsyncHttpRequest：异步网络请求 \n * RequestHandle: 控制异步网络请求的取消和运行 \n * 通过标志位判断和取消网络请求 \n  \n ```java \n AsyncHttpRequest request = new AsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context); \n         threadPool.submit(request); \n ``` \n  \n ##异步方式下的网络请求数据流程 \n * `AsyncHttpRequest`是一个线程，加入线程池，执行`run()`方法进行网络请求 \n * 执行完毕后，回调成员变量`TextHttpResponseHandler`的`onSuccess()`方法将返回数据交由其处理 \n * `TextHttpResponseHandler `（及其子类）获取数据进行解析加工 \n  \n ##线程池如何处理的 \n  \n `AsyncHttpClient` \n ```java \n  \n private ExecutorService threadPool; \n  \n threadPool = Executors.newCachedThreadPool(); \n  \n AsyncHttpRequest request = new AsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context); \n  \n threadPool.submit(request); \n ```"}