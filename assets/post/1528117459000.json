{"title":"依赖倒置","createTime":1528117459000,"updateTime":-1,"category":"架构设计","content":" \n  \n ## 依赖倒置  \n  \n 依赖倒置是面对对象设计的标志，依赖于抽象或接口进行编程。 \n  \n **What** \n  \n Dependence Inversion Principle (DIP) ,高层模块应该依赖于抽象，而不能直接依赖底层模块的具体实现 \n  \n **Why** \n  \n 传统的：修改功能时，必须修改底层模块原有的实现代码，甚至导致修改高层模块代码。违背了开放封闭原则。 \n  \n \t底层模块（具体实现）--> 高层模块（调用底层模块实现用户场景功能） \n  \n 依赖倒置后：只要抽象/接口不变，高层模块就不用变化。修改实现代码也可通过新增代码文件来实现，而不需要修改原有代码。 \n \t\t \n \t抽象/接口 --> 底层模块（实现接口的具体功能） \n \t抽象/接口 --> 高层模块（调用接口实现用户场景功能） \n  \n \t \n **How** \n  \n 三个模块 \n  \n * IService \n * ServiceImpl \n * UI \n  \n 调用流程 \n  \n 1. IService-> ServiceImpl  \n 2. UI层通过注入赋值得到IService实例 \n 3. UI层功能-> IService.execute();  \n \t \n  \n  \n ## 控制反转 \n  \n `new`对象地方的转移 \n  \n **What** \n  \n Inversion of Control(IoC) :对象控制权（new对象的权利）进行转移，转移到第三方，比如交给IoC容器，它就是一个创建对象的工厂，你要什么对象，它就给你什么对象。有了IoC容器，原来的依赖关系就没了，都变成了依赖IoC容器了。 \n   \n  \n **why** \n  \n 一般程序流程 \n \t\t \n \tUI层功能1-> new ServiceImpl(param1, param2, param3) \n \tUI层功能2-> new ServiceImpl(param1, param2, param3) \n \tUI层功能3-> new ServiceImpl(param1, param2, param3) \n  \n 以上设计需要UI层里面`new ServiceImpl()`,从而导致依赖了底层的具体实现，会有如下缺点： \n  \n 1. 依赖了底层的具体实现，违反了依赖倒置原则 \n 2. 需要多次new一个ServiceImpl对象，浪费资源 \n 3. UI层需要知道如何怎么ServiceImpl的构造参数，依赖哪些对象，从而增加代码复杂度，并产生很多重复代码  \n  \n 可以利用控制反转的思想解决上述缺点 \n  \n **how** \n  \n 两个实现方法: \n  \n 1. 依赖注入  \n 2. Service Locator \n  \n  \n ### 依赖注入 \n  \n Dependency Injection \n  \n 让IoC容器去`new` ServiceImpl实例，并通过“注入”的方式赋值给UI层。实现和底层ServiceImpl的解耦 \n  \n  \n ### Service Locator \n  \n 让UI层全部依赖ServiceLocator,由ServiceLocator提供各种ServiceImpl实例，实现和底层ServiceImpl的解耦 \n  \n  \n 一般流程： \n  \n 1. ServiceLocator.registerService(); \n 2. ServiceLocator.getServcie(); \n  \n  \n ```java \n  \n public class ServiceManager { \n  \n     private static final ServiceManager ourInstance = new ServiceManager(); \n     private HashMap<String, BaseService> mServiceHashMap = new HashMap<>(); \n  \n     public static ServiceManager getInstance() { \n         return ourInstance; \n     } \n  \n     private ServiceManager() { \n     } \n  \n     public void registerService(String serviceName, BaseService service) { \n         if (null == serviceName || null == service) { \n             return; \n         } \n  \n         mServiceHashMap.put(serviceName, service); \n     } \n  \n     public BaseService getService(String serviceName) { \n         return mServiceHashMap.get(serviceName); \n     } \n } \n ``` \n  \n #### 疑问？ \n  \n ServieImpl的`new`是在ServiceLocator中呢，还是其他地方？还是都可以 \n  \n ### 依赖注入和Service Locator对比 \n  \n 1. Service Locator允许你在一个类 中“解决”依赖问题 \n 2. DI允许你从类外“注入”依赖 \n 3. 当使用service locator时，每个类都有一个对service locator的依赖 \n  \n  \n  \n  \n  \n  \n  \n  \n  \n "}