{"title":"Android Font Typeface","createTime":1474275623000,"updateTime":-1,"category":"default","content":" \n  \n Android 官方Typeface：Droid sans, Droid Sans Mono, Droid Serif, Default sans \n  \n TextStyle: normal, bload, italic \n  \n ##### 常用Spannable类 \n \t \n \t字体颜色：ForegroundColorSpan \n \t字体背景颜色：BackgroundColorSpan \n \t字体大小：AbsoluteSizeSpan \n \t粗体，斜体：StyleSpan \n \t删除线：StrikeThroughSpan \n \t下划线：UnderlineSpan \n \t图片：ImageSpan \n \t字体：TypefaceSpan \n \t自定义字体：class CustomTypefaceSpan extends TypefaceSpan \n  \n 使用方法 \n  \n ```java \n SpannableString spanString = new SpannableString(\"xxxxx\");     \n StyleSpan span = new StyleSpan(Typeface.BOLD_ITALIC);     \n spanString.setSpan(span, 1, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);     \n textView.setText(spanString);    \n ``` \n  \n  \n ##### `setTypeface`设置自定义字体 \n  \n ```java \n TextView txt = (TextView) findViewById(R.id.custom_font); \n Typeface font = Typeface.createFromAsset(getAssets(), \"Chantelli_Antiqua.ttf\"); \n txt.setTypeface(font); \n ``` \n  \n ##### `CustomeTypefaceSpan`设置自定义字体 \n  \n 使用 \n  \n ```java \n Typeface typeface = Typeface.createFromAsset(getAssets(), \"Akshar.ttf\"); \n SpannableString str = new SpannableString(\"hello world\"); \n str.setSpan(new CustomTypefaceSpan(\"\", typeface), 0, string.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); \n ``` \n  \n CustomeTypefaceSpan.java \n  \n ```java \n public class CustomTypefaceSpan extends TypefaceSpan { \n  \n private final Typeface newType; \n  \n public CustomTypefaceSpan(String family, Typeface type) { \n     super(family); \n     newType = type; \n } \n  \n @Override \n public void updateDrawState(TextPaint ds) { \n     applyCustomTypeFace(ds, newType); \n } \n  \n @Override \n public void updateMeasureState(TextPaint paint) { \n     applyCustomTypeFace(paint, newType); \n } \n  \n private static void applyCustomTypeFace(Paint paint, Typeface tf) { \n     int oldStyle; \n     Typeface old = paint.getTypeface(); \n     if (old == null) { \n         oldStyle = 0; \n     } else { \n         oldStyle = old.getStyle(); \n     } \n  \n     int fake = oldStyle & ~tf.getStyle(); \n     if ((fake & Typeface.BOLD) != 0) { \n         paint.setFakeBoldText(true); \n     } \n  \n     if ((fake & Typeface.ITALIC) != 0) { \n         paint.setTextSkewX(-0.25f); \n     } \n  \n     paint.setTypeface(tf); \n } \n } \n  \n ``` \n  \n [How set Spannable object font with custom font](http://stackoverflow.com/questions/6612316/how-set-spannable-object-font-with-custom-font) \n  \n  \n ##### 自定义字体可能导致的问题 \n  \n 1. Ellipsizing might not work correctly if the font dosen't have a glyph for ellipsis character（没有省略字符的话导致肾略效果失效） \n 2. internationalization might not be supported（可能对国际化，多语言不支持） \n 3. 增加了apk的体积 \n  \n 老版本的new TypeFace()会存在内存泄漏,此bug在Android 3.2上已fixed \n  \n 处理内存泄漏fix方案： \n  \n ```java \n public class FontCache { \n  \n     private static Hashtable<String, Typeface> fontCache = new Hashtable<String, Typeface>(); \n  \n     public static Typeface get(String name, Context context) { \n         Typeface tf = fontCache.get(name); \n         if(tf == null) { \n             try { \n                 tf = Typeface.createFromAsset(context.getAssets(), name); \n             } \n             catch (Exception e) { \n                 return null; \n             } \n             fontCache.put(name, tf); \n         } \n         return tf; \n     } \n } \n ``` \n  \n http://stackoverflow.com/questions/16901930/memory-leaks-with-custom-font-for-set-custom-font/16902532#16902532   \n https://code.google.com/p/android/issues/detail?id=9904   \n  \n  \n ##### Typeface源码 \n  \n Typeface.create()方法返回的Typeface是存在缓存的 \n  \n ```java \n \tpublic static Typeface create(String familyName, int style) { \n         if (sSystemFontMap != null) { \n             return create(sSystemFontMap.get(familyName), style); \n         } \n         return null; \n     }orm \n      \n     public static Typeface create(Typeface family, int style) { \n     \t Typeface typeface; \n     \t //private static final LongSparseArray<SparseArray<Typeface>> sTypefaceCache = new LongSparseArray<SparseArray<Typeface>>(3); \n         SparseArray<Typeface> styles = sTypefaceCache.get(ni); \n  \n         if (styles != null) { \n             typeface = styles.get(style); \n             if (typeface != null) { \n                 return typeface; \n             } \n         } \n     } \n ``` \n  \n 但是`public static Typeface createFromAsset(AssetManager mgr, String path)`创建的Typeface好像不存在缓存，反正代码是没看懂 \n  \n [Does Typeface.createFromAsset() cache?](http://stackoverflow.com/questions/4320090/does-typeface-createfromasset-cache) \n  \n 测试加载一个8M的字体文件耗时100ms,200kb的字体文件20ms \n  \n ##### String.format()格式化时保留SpannableString 样式 \n  \n 默认的情况下String.format()传入的SpannableString会当做普通的String处理，不会保留SpannableString中字体，样式等特性 \n  \n ```java \n /** \n  *  \n  * @author George T. Steel \n  * \n  */ \n public class SpanFormatter { \n \tpublic static final Pattern FORMAT_SEQUENCE\t= Pattern.compile(\"%([0-9]+\\\\$|<?)([^a-zA-z%]*)([[a-zA-Z%]&&[^tT]]|[tT][a-zA-Z])\"); \n \t \n \tprivate SpanFormatter(){} \n \t \n \tpublic static SpannedString format(CharSequence format, Object... args) { \n         return format(Locale.getDefault(), format, args); \n     } \n \t \n \tpublic static SpannedString format(Locale locale, CharSequence format, Object... args){ \n \t\tSpannableStringBuilder out = new SpannableStringBuilder(format); \n \t\t \n \t\tint i = 0; \n \t\tint argAt = -1; \n \t\t \n \t\twhile (i < out.length()){ \n \t\t\tMatcher m = FORMAT_SEQUENCE.matcher(out); \n \t\t\tif (!m.find(i)) break; \n \t\t\ti=m.start(); \n \t\t\tint exprEnd = m.end(); \n \t\t\t \n \t\t\tString argTerm = m.group(1); \n \t\t\tString modTerm = m.group(2); \n \t\t\tString typeTerm = m.group(3); \n \t\t\t \n \t\t\tCharSequence cookedArg; \n \t\t\t \n \t\t\tif (typeTerm.equals(\"%\")){ \n \t\t\t\tcookedArg = \"%\"; \n \t\t\t}else if (typeTerm.equals(\"n\")){ \n \t\t\t\tcookedArg = \"\\n\"; \n \t\t\t}else{ \n \t\t\t\tint argIdx = 0; \n \t\t\t\tif (argTerm.equals(\"\")) argIdx = ++argAt; \n \t\t\t\telse if (argTerm.equals(\"<\")) argIdx = argAt; \n \t\t\t\telse argIdx = Integer.parseInt(argTerm.substring(0, argTerm.length() - 1)) -1; \n \t\t\t\t \n \t\t\t\tObject argItem = args[argIdx]; \n \t\t\t\t \n \t\t\t\tif (typeTerm.equals(\"s\") && argItem instanceof Spanned){ \n \t\t\t\t\tcookedArg = (Spanned) argItem; \n \t\t\t\t}else{ \n \t\t\t\t\tcookedArg = String.format(locale, \"%\"+modTerm+typeTerm, argItem); \n \t\t\t\t} \n \t\t\t} \n \t\t\t \n \t\t\tout.replace(i, exprEnd, cookedArg); \n \t\t\ti += cookedArg.length(); \n \t\t} \n \t\t \n \t\treturn new SpannedString(out); \n \t} \n } \n ``` \n  \n 参考 \n  \n [Combining Spannable with String.format()](http://stackoverflow.com/questions/20936901/combining-spannable-with-string-format)   \n [a version of String.format](https://github.com/george-steel/android-utils/blob/master/src/org/oshkimaadziig/george/androidutils/SpanFormatter.java)"}